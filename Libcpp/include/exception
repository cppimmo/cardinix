#ifndef LIBCPP_EXCEPTION_H
#define LIBCPP_EXCEPTION_H

namespace std
{
	class exception;
	class bad_exception;
	class nested_exception;

	using terminate_handler = void(*)();
	terminate_handler get_terminate() noexcept;
	terminate_handler set_terminate(terminate_handler pHandler) noexcept;
	[[noreturn]] void terminate() noexcept;

	int uncaught_exceptions() noexcept;

	// using exception_ptr = shared_ptr<exception>;

	//exception_ptr current_exception() noexcept;
	//[[noreturn]] void rethrow_exception(exception_ptr pException);

	//template <class E>
	//exception_ptr make_exception_ptr(E e) noexcept;
	
	template <class T>
	[[noreturn]] void throw_with_nested(T &&t);
	template <class E>
	void rethrow_if_nested(const E &e);
	
	class exception
	{
	public:
		exception() noexcept = default;
		exception(const exception&) noexcept = default;
		exception &operator=(const exception&) noexcept = default;
		virtual ~exception() = default;
		virtual const char *what() const noexcept;
	};

	class bad_exception : public exception
	{
	public:
		bad_exception() noexcept = default;
		bad_exception(const bad_exception&) noexcept = default;
		bad_exception &operator=(const bad_exception&) noexcept = default;
		const char *what() const noexcept override;
	};

	class nested_exception : public exception
	{
	public:
		nested_exception() noexcept = default;
		nested_exception(const nested_exception&) noexcept = default;
		nested_exception &operator=(const nested_exception&) noexcept = default;
		virtual ~nested_exception() = default;

		[[noreturn]] void rethrow_nested() const;
		// exception_ptr nested_ptr() const noexcept;
	};
	
}
	
#endif // LIBCPP_EXCEPTION_H
