#ifndef LIBCPP_STDEXCEPT
#define LIBCPP_STDEXCEPT

#include "exception"

namespace std
{
	class logic_error;
	class invalid_argument;
	class domain_error;
	class length_error;
	class out_of_range;
	class runtime_error;
	class range_error;
	class overflow_error;
	class underflow_error;
	
	class logic_error : public exception
	{
	public:
		// explicit logic_error(const std::string &what);
		explicit logic_error(const char *what);
		logic_error(const logic_error&) noexcept = default;
		logic_error &operator=(const logic_error&) noexcept = default;

		virtual const char *what() const noexcept override;
	private:
		// const std::string whatstr;
	};

	class domain_error : public logic_error
	{
	public:
		// explicit domain_error(const std::string &what);
		explicit domain_error(const char *what);
		domain_error(const domain_error&) noexcept = default;
		domain_error &operator=(const domain_error&) noexcept = default;
	};
	
	class invalid_argument : public logic_error
	{
	public:
		// explicit invalid_argument(const std::string &what);
		explicit invalid_argument(const char *what);
		invalid_argument(const invalid_argument&) noexcept = default;
		invalid_argument &operator=(const invalid_argument&) noexcept = default;
	};
	
	class length_error : public logic_error
	{
	public:
		// explicit length_error(const std::string &what);
		explicit length_error(const char *what);
		length_error(const length_error&) noexcept = default;
		length_error &operator=(const length_error&) noexcept = default;
	};
	
	class out_of_range : public logic_error
	{
	public:
		// explicit out_of_range(const std::string &what);
		explicit out_of_range(const char *what);
		out_of_range(const out_of_range&) noexcept = default;
		out_of_range &operator=(const out_of_range&) noexcept = default;
	};
	
	class runtime_error : public exception
	{
	public:
		// explicit runtime_error(const std::string &what);
		explicit runtime_error(const char *what);
		runtime_error(const runtime_error&) noexcept = default;
		runtime_error &operator=(const runtime_error&) noexcept = default;
	};
	
	class range_error : public runtime_error
	{
	public:
		// explicit range_error(const std::string &what);
		explicit range_error(const char *what);
		range_error(const range_error&) noexcept = default;
		range_error &operator=(const range_error&) noexcept = default;
	};
	
	class overflow_error : public runtime_error
	{
	public:
		// explicit overflow_error(const std::string &what);
		explicit overflow_error(const char *what);
		overflow_error(const overflow_error&) noexcept = default;
	    overflow_error &operator=(const overflow_error&) noexcept = default;
	};
	
	class underflow_error : public runtime_error
	{
	public:
		// explicit underflow_error(const std::string &what);
		explicit underflow_error(const char *what);
		underflow_error(const underflow_error&) noexcept = default;
  		underflow_error &operator=(const underflow_error&) noexcept = default;
	};
	
}

#endif // LIBCPP_STDEXCEPT
